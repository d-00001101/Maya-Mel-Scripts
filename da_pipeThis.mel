//copyright 2009 Daniel Arzabe////This procedure creates a neat pipe along a curve of any degree.//It is meant to alleviate the drudgery of filleting curves to get a clean extrusion.//The proc uses a radius value for the girth of the pipe and an offset value //determines the curvature of the bend of the pipe at the corners. If the offset value//is greater than the length of the span it will adjust the offset value so that//the end result does not contain any intersecting geometry and //minimal loss of volume at acute angles along the curve.////USAGE://select a curve and execute command: da_pipeThisUI();////ARGUMENTS://1.) $output -> "NURBS" or "Polygons"//2.) $laoutUVs -> 0 or 1 (off or on)//3.) $constructionHistory -> 0 or 1 (off or on)//4.) $keepOriginal -> 0 or 1 (off or on)//5.) $radius -> float (girth of pipe)//6.) $offset -> float (size of bend around the corners)////RETURN://The proc will produce a group containing the profile circle, //the new pipe curve, a nurbs and or poly mesh if $constructionHistory is set to 1.proc da_pipeThis(string $output, int $layoutUVs, int $constructionHistory, int $keepOriginal, float $radius, float $offset){		/*if(  ($output == "polygons") || ($output == "Polygons") || ($output == "polygon") || ($output == "Polygon") )	{		//print("POLYGONS\n");	}*/	string $sel[] = `ls -sl`;	if( size($sel) < 1 )	{		error("Please select a curve.");	}	string $childShape[] =`listRelatives -shapes $sel[0]`;	print($childShape[0] + "\n");	int $degree = `getAttr ($sel[0] + "|" + $childShape[0] + ".degree")`;	print("degree = " + $degree + "\n");	int $form = `getAttr ($sel[0] + ".form")`;	if($degree != 1)	{		error("Please select a 1 degree curve.");	}	if($form != 0)	{		error("Please select a periodic curve.");	}	//the group that will contain all objects	string $group = `group -w -em -n ($sel[0] + "_pipeGroup")`;	//parent $sel[0] $group;	//the length of the span	float $distanceA;	float $distanceB;	//list of cvs for new curve	vector $newCvs[];	print("childShape = " + $childShape[0] + "\n");	//number of spans in curve	int $numSpans = `getAttr ($sel[0] + "|" + $childShape[0] + ".spans")`;	string $newCircles[];	//iteration variables	int $i = 0;	int $newIndex = 0;	//start and end position of current span cvs	vector $startVecA;	vector $endVecA;	vector $deltaA;	//start and end positions of adjacent span cvs	vector $startVecB;	vector $endVecB;	vector $deltaB;	//temporary newCVs position	vector $tempPosA;		vector $tempPosB;	float $tempDistA;	float $tempDistB;	float $shorterDist;			//print("\n\n________________________________________________________________\n\n");	for($i=0; $i < $numSpans; $i++)	{		$startVecA = `xform -q -ws -translation ($sel[0] + ".cv[" + $i + "]")`;		//print ("Start vec A = " + $startVecA + "\n");		$endVecA = `xform -q -ws -translation ($sel[0] + ".cv[" + ($i+1) + "]")`;		//print ("End vec A = " + $endVecA + "\n");			$deltaA =  $endVecA - $startVecA;		//print("Delta full A = " + $deltaA + "\n");		$distanceA = mag ($deltaA);		//print("Distance A = " + $distanceA + "\n");		string $newCircles[];		//create the first cv on curve		if($i < 1)		{			if(  ($output == "polygons") || ($output == "Polygons") || ($output == "polygon") || ($output == "Polygon") )			{				//create a degree 1 circle if output is polygons				$newCircles[0] = `curve -d 1 							-p 0 -1 0 							-p 0 -0.707107 -0.707107							-p 0 0 -1							-p 0 0.707107 -0.707107							-p 0 1 0							-p 0 0.707107 0.707107							-p 0 0 1 							-p 0 -0.707107 0.707107							-p 0 -1 0							-n ($sel[0] + "_pipeProfile")`;				setAttr ($newCircles[0] + ".translate") ($startVecA.x) ($startVecA.y) ($startVecA.z);				parent $newCircles[0] $sel[0];				setAttr ($sel[0] + "|" + $newCircles[0] + ".rotate") 0 0 0;				setAttr ($sel[0] + "|" + $newCircles[0] + ".scale") $radius $radius $radius;				parent  -w ($sel[0] + "|" + $newCircles[0]);			}			else			{				//create the circle				$newCircles = `circle 	-c ($startVecA.x) ($startVecA.y) ($startVecA.z) 							-nr ($deltaA.x) ($deltaA.y) ($deltaA.z)							-sw 360 -r $radius -d 3 -ut 0 -tol 5.45957e-009 							-s 8 -ch 1 -n ($sel[0] + "_pipeProfile")`; 			}			select -r $newCircles[0];			CenterPivot;			parent $newCircles[0] $group;			select -cl;			$newCvs[$newIndex] = $startVecA;			//print("new cv = " + $newCvs[$newIndex] + "\n");			$newIndex++;			//print("new index = " + $newIndex + "\n");					}		$startVecB = `xform -q -ws -translation ($sel[0] + ".cv[" + ($i + 1) + "]")`;		//print ("Start vec B = " + $startVecB + "\n");		$endVecB = `xform -q -ws -translation ($sel[0] + ".cv[" + ($i + 2) + "]")`;		//print ("End vec B= " + $endVecB + "\n");					$deltaB =  $endVecB - $startVecB;		//print("Delta full B = " + $deltaB + "\n");		$distanceB = mag ($deltaB);		//print("Distance B = " + $distanceB + "\n");					//if both spans are shorter than required	 given the radius and offset values,		//then find the smaller of the two and use it to calculate the positions		// of the new cvs on both spans		if(   ($distanceA < (($radius * 2) + ($offset*2))   ||    $distanceB < (($radius * 2) + ($offset*2))) && ($i != ($numSpans - 1))   )		{			$tempPosA = $startVecA + (($deltaA/2) + (($deltaA/2) * .04));			float $tempA = mag( ($endVecA - $tempPosA) );			//print("New distanceA = " + $tempA + "\n");			$tempPosB = $startVecB + (($deltaB/2) + (($deltaB/2) * .04));			float $tempB = mag( ($endVecB - $tempPosB) );			//print("New distanceB = " + $tempB + "\n");			if( $tempA < $tempB)			{				$shorterDist = $tempA;					}				else			{				$shorterDist = $tempB;				}			//find the ratio of the small distance to the length			//of each spans to calculate the position of the new cvs			//create directional cv at start of new curve			if($i < 1)			{				$newCvs[$newIndex] = $startVecA + ( $deltaA * ($shorterDist/$distanceA) ); 				//print("new DIRECTIONAL cv = " + $newCvs[$newIndex] + "\n");				$newIndex++;				//print("new index = " + $newIndex + "\n");							}				//create the new cv at end of first span				$newCvs[$newIndex] = $endVecA - ( $deltaA * ($shorterDist/$distanceA) ); 			//print("new cv = " + $newCvs[$newIndex] + "\n");			$newIndex++;			//print("new index = " + $newIndex + "\n");			//create the corner cv			$newCvs[$newIndex] = $endVecA; 			//print("new cv = " + $newCvs[$newIndex] + "\n");			$newIndex++;			//print("new index = " + $newIndex + "\n");			//create the new cv at start of second span			$newCvs[$newIndex] = $endVecA + ( $deltaB * ($shorterDist/$distanceB) );				//print("new cv = " + $newCvs[$newIndex] + "\n");			$newIndex++;			//print("new index = " + $newIndex + "\n");			//create the end directional cv			if( ($i + 2) == $numSpans)			{				$newCvs[$newIndex] = $endVecB - ( $deltaB * ($shorterDist/$distanceB) );				//print("new cv = " + $newCvs[$newIndex] + "\n");				$newIndex++;				//print("new index = " + $newIndex + "\n");			}			}		else if( ($i + 1) != $numSpans)		{			//print("\n inside IF ELSE STATEMENT \n");			float $percentageA = ($radius + $offset)/$distanceA;			//print("percentage A of distance A = " + $percentageA + "\n");									float $percentageB = ($radius + $offset)/$distanceB;			//print("percentage B of distance B = " + $percentageB + "\n");			//create the directional cv if the first span's distance is greater than radius plus offset			if($i < 1)			{				$newCvs[$newIndex] = $startVecA + ($deltaA * $percentageA);				//print("new cv = " + $newCvs[$newIndex] + "\n");				$newIndex++;				//print("new index = " + $newIndex + "\n");			}							$newCvs[$newIndex] = $endVecA - ($deltaA * $percentageA);			//print("new cv = " + $newCvs[$newIndex] + "\n");			$newIndex++;			//print("new index = " + $newIndex + "\n");				//print("out of IF ELSE STATEMENT \n");			//create the corner cv if it is not the last span			if( ($i + 1) != $numSpans )			{				$newCvs[$newIndex] = $endVecA; 				//print("new LAST CORNER cv = " + $newCvs[$newIndex] + "\n");					$newIndex++;				//print("new index = " + $newIndex + "\n");			}			$newCvs[$newIndex] = $startVecB + ($deltaB * $percentageB);			//print("new cv = " + $newCvs[$newIndex] + "\n");			$newIndex++;			//print("new index = " + $newIndex + "\n");			//create the end directional cv			if( ($i + 2) == $numSpans)			{				$newCvs[$newIndex] = $endVecB - ($deltaB * $percentageB);				//print("new cv = " + $newCvs[$newIndex] + "\n");				$newIndex++;				//print("new index = " + $newIndex + "\n");			}		}				if( ($i + 1) == $numSpans )			{			$newCvs[$newIndex] = $endVecA;			//print("END cv = " + $newCvs[$newIndex] + "\n");				$newIndex++;			//print("new index = " + $newIndex + "\n");		}	}	//these vars are used to calculate the knot values for the new curve	float $currentParam = 0;	float $newKnots[];	float $deltaSums = 0;	int $numCvs = size($newCvs);	//print("Number of Cvs = " + $numCvs + "\n");		int $j = 1;	$newKnots[0] = 0;	for($j; $j < $numCvs; $j++)	{		if($j == 1)		{			//print("----Current param = " + $currentParam + "\n");			//print("Delta Sums = " + $deltaSums + "\n");		}		$currentParam = mag($newCvs[$j] - $newCvs[$j - 1]);		//print("----Current param = " + $currentParam + "\n");		$deltaSums += $currentParam;		//print("Delta Sums = " + $deltaSums + "\n");		$newKnots[$j] = $deltaSums;			}	//print("Size of new knots = " + (size($newKnots)) + "\n");		string $curveCommand = "curve -d 3 ";	vector $currentCV;	float $knot;	//concatenate -position values	for($currentCV in $newCvs)	{		$curveCommand += " -p ";		$curveCommand += $currentCV;		//print($curveCommand + "\n");	}	//concatenate -knot values omiting the second and second to last new cv positions	//because they are directional cvs and so do not have a corresponding edit point in a degree 3 curve	int $q = 0;	for($q= 0; $q < $numCvs; $q++)	{		if($q == 0)		{			$curveCommand += " -k " + $newKnots[$q];			$curveCommand += " -k " + $newKnots[$q];		}		if($q != 1)		{			if($q != ($numCvs - 2))			{				$curveCommand += " -k " + $newKnots[$q];			}		}		if( $q == ($numCvs - 1) )		{			$curveCommand += " -k " + $newKnots[$q];			$curveCommand += " -k " + $newKnots[$q];			}	}	$curveCommand += (" -n " + $sel[0] + "_pipeCurve;") ;	//print ($curveCommand + "\n");	string $newCurve = `eval $curveCommand`;	CenterPivot;	string $newCurveShape[] =`listRelatives -shapes $newCurve`;	rename $newCurveShape[0] ($newCurve + "Shape");	setAttr ($newCurve + ".dispCV") 1;	//setAttr ($newCurve + ".dispEP") 1;	parent $newCurve $group;	string $extrusions[] = `extrude 	-ch true -rn false -po 0 -et 2 -ucp 1 -fpt 1 						-upn 1 -rotation 0 -scale 1 -rsp 1 						-n ($sel[0] + "_nurbsPipe") 						($group + "|" + $newCircles[0]) ($group + "|" + $newCurve)` ;	CenterPivot;		parent $extrusions[0] $group;	string $polyPipe[];	if($output == "polygons" || $output == "Polygons" || $output == "polygon" || $output == "Polygon")	{		$polyPipe = `nurbsToPoly 	-mnd 1  -ch 1 -f 3 						-pt 1 -pc 200 -chr 0.9 						-ft 0.01 -mel 0.001 -d 0.1 						-ut 2 -un 1 -vt 2 -vn 1 						-uch 0 -ucr 0 -cht 0.01 						-es 0 -ntr 0 -mrt 0 -uss 1 						-n ($sel[0] + "_polyPipe") 						($group + "|" + $extrusions[0])`;		CenterPivot;		setAttr ($group + "|" + $extrusions[0] + ".template") 1;	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////				if($layoutUVs)		{			int $vSpans = size($newCvs);						select -r $polyPipe[0];			//convert selection to verts			PolySelectConvert 3;						string $selVT[] = `ls -sl -fl`;			int $max = size($selVT);			//print("Num of verts = " + $max + "\n");			int $amount = 0;			    progressWindow         			-title "Laying Out UVs"         			-progress $amount         			-status "Processing: 0%"         			-isInterruptable true;						for( $t = 0; $t < $vSpans; $t++)			{				select -cl;				select ($group + "|" + $extrusions[0] + ".cv[0:8][" + $t + "]");				string $selCV[] = `ls -sl -fl`;				//print ($selCV);// + "\n");							string $nearest[];								//print("//Span " + $t + "\n");							for($i = 0; $i < size($selCV); $i++)				{											vector $cvPos = `xform -q -ws -translation $selCV[$i]`;										$amount++;					//print("Amount = " + $amount + "\n");					int $progressVal = ((float)$amount/(float)$max ) * 100;					//print("Progress val = " + $progressVal + "\n");					progressWindow 	-edit            						 	-progress $progressVal            						 	-status ("Processing: " + $progressVal + "%");					for( $j = 0; $j < size($selVT); $j++)					{						vector $vertPos = `xform -q -ws -translation $selVT[$j]`;												vector $difference = $cvPos - $vertPos;									float $distance = mag($difference);									if($distance < .004)						{							$nearest[size($nearest)] = $selVT[$j];							//print("select -add " + $selVT[$j] + ";\n");														select -r $selVT[$j];							PolySelectConvert 4;							string $currentUV[] = `ls -sl -fl`;								//print("The knot value for this row of verts = " + $newKnots[$t] + "current UV = " + $currentUV[0] + "\n");																				polyEditUV -r false -v $newKnots[$t] $currentUV[0];								select -cl;						}											}												}				}						progressWindow -endProgress;		}	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		parent $polyPipe[0] $group;	}		if($constructionHistory < 1)	{		string $children[] = `listRelatives -c -fullPath $group`;		//print("Children = \n");		//print($children);		delete $children[0];		delete $children[1];		if($output == "polygons" || $output == "Polygons" || $output == "polygon" || $output == "Polygon")		{			select -cl;			select -r $children[3];			DeleteHistory $children[3];			delete $children[2];		}	}			if($keepOriginal < 1)	{		delete $sel[0];	}		}proc string da_getPipeValues(string $outputGeoRG, string $layoutUVsCB, string $historyCB, string $keepOrCB, string $radiusFF, string $offsetFF){	//print ("Inside daGetPipeValues\n");	string $output;	int $outputNum =  `radioButtonGrp -q -sl $outputGeoRG`;	if($outputNum == 2)	{		$output = "Polygons";	}		//print ("This is the output - " + $output + "\n");	int $layoutUVs = `checkBox -q -v $layoutUVsCB`;	int $constructionHistory = `checkBox -q -v $historyCB`;	int $keepOriginal = `checkBox -q -v $keepOrCB`;	float $radius = `floatField -q -v $radiusFF`;	float $offset = `floatField -q -v $offsetFF`;	string $command = "da_pipeThis(\"" + $output + "\"," + $layoutUVs  + "," + $constructionHistory + "," + $keepOriginal + "," + $radius + "," + $offset + ");"; 	return $command;}proc da_pipeThisUI(){	string $pipeThisWindow = `window 	-title "pipeThis"					-iconName "pipeThis"					-s true -wh 260 100					-rtf true "pipeThisWindow"`;	columnLayout;		rowColumnLayout -nc 2 -cw 1 100 -cw 2 70;			text -align "right" -label "Pipe Radius   ";			string $radiusFF = `floatField -minValue 0 -v 1`; 			text -align "right" -label "Corner Radius   ";			string $offsetFF = `floatField -minValue 0 -v .5`; 					setParent ..;		separator -w 260 -h 10;		string $outputGeoRG = `radioButtonGrp 	-cw 1 100 -cw 2 80 -cw 3 80					-numberOfRadioButtons 2    					-label "Output Geometry" -select 1					-labelArray2 "NURBS" "Polygons"`;		setParent ..;		rowColumnLayout -nc 2 -cw 1 100 -cw 2 160;			text -l "";			string $layoutUVsCB = `checkBox -label "Layout UVs"   -align "left"`;			text -l "";			string $historyCB = `checkBox -label "Construction History"   -align "left"`;		setParent ..;		separator -w 260 -h 10;		rowColumnLayout -nc 2 -cw 1 100 -cw 2 160;			text -l "";			string $keepOrCB = `checkBox -label "Keep Original"   -align "left" -v true`;		setParent ..;		separator -h 10 -st "none";		string $confirmButton = `button 	-w 260 -l "Apply" 		-c ("eval ( da_getPipeValues(\"" + $outputGeoRG + "\",\"" + $layoutUVsCB  + "\",\"" + $historyCB + "\",\"" + $keepOrCB + "\",\"" + $radiusFF + "\",\"" + $offsetFF + "\") );") `;			showWindow $pipeThisWindow;}